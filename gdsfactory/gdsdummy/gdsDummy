#!/usr/bin/python3

from datetime import datetime
from enum import IntEnum
import re
import pprint
import gdsfactory as gf
import sky130 as pdk

class Dir(IntEnum):
   I = 0
   O = 1
   IO = 2
   PWR = 3
   X = -1

class Edge(IntEnum):
   N = 0
   E = 1
   S = 2
   W = 3

class Pin():

   def __init__(self, name, direction, position, bits=1, bit_from=None, bit_to=None):
      self.name = name
      self.direction = direction
      self.bits = bits
      self.polygon = [None] * bits
      if bit_from is None:
         self.bus = False
      else:
         self.bus = True
         self.bit_from = bit_from
         if bit_to is None:
            raise(Exception)
         else:
            self.bit_to = bit_to
      if not isinstance(position, tuple):
         self.edge = position
         self.placement = -1
      else:
         self.edge = position[0]
         self.placement = position[1]

   def add_polygon(self, pin, strand, coords, **kwargs):
      #wtf polygon should be (coords,layer) at least
      if strand is None:
         self.polygon[0] = (coords[0][0], coords[0][1], coords[2][0], coords[2][1])
      else:
         self.polygon[strand] = (coords[0][0], coords[0][1], coords[2][0], coords[2][1])
      pin.add_polygon(coords, **kwargs)

   def __repr__(self):
      return pprint.pformat(vars(self), indent=4, width=1)

class GDSDummy():

   Pwr = {'VDD': True, 'VCS': True, 'GND': True, 'GD': True, 'vdd': True, 'vcs': True, 'gnd': True, 'gd': True}
   PortLayers = {68: 'met1', 69: 'met2', 70: 'met3', 71: 'met4', 72: 'met5'}

   def __init__(self, name, size):
      self.name = name
      self.size = size
      self.width = size[0]
      self.height = size[1]
      self.pins = []
      self.compLayer = (235,4)
      self.pinWidth = 4
      self.pinHeight = .6
      self.pinLayer = (70,16)
      self.pinSpacing = 4
      self.origin = (0, 0)
      self.xOffset = self.pinSpacing
      self.yOffset = self.pinSpacing
      self.verilogFile = f'{self.name}.v'

   def add_pin(self, pin):
      self.pins.append(pin)

   def gen_gds(self):

      width = self.size[0]
      height = self.size[1]
      lastPin = [-1, -1, -1, -1]

      @gf.cell
      def top(width, height):
         c = gf.Component(self.name)
         c.add_polygon(
            [(0, 0), (0, height), (width, height), (width, 0)], layer=self.compLayer
         )
         for p in self.pins:

            for i in range(p.bits):

               if p.bus:
                  if p.bit_from >= p.bit_to:
                     strand = p.bit_from - i
                  else:
                     strand = p.bit_from + i
                  name = f'{p.name}[{strand}]'
               else:
                  strand = None
                  name = p.name

               pin = gf.Component(name)
               lastPlacement = lastPin[p.edge]
               if p.placement == -1:
                  placement = lastPlacement + 1
               else:
                  placement = p.placement
               # need to record and check for coll
               lastPin[p.edge] = placement

               if p.edge == Edge.N:
                  x = self.xOffset + placement * self.pinSpacing
                  y = self.height
                  orientation = 90
               elif p.edge == Edge.E:
                  x = self.width
                  y = self.yOffset + placement * self.pinSpacing
                  orientation = 180
               elif p.edge == Edge.S:
                  x = self.xOffset + placement * self.pinSpacing
                  y = -self.pinHeight
                  orientation = 270
               else:
                  x = -self.pinWidth
                  y = self.yOffset + placement * self.pinSpacing
                  orientation = 0

               #print(f'{name} {p.edge}/{p.placement} {x},{y}')
               if orientation == 90:
                  p.add_polygon(pin, strand,
                     [(x, y), (x, y + self.pinWidth), (x + self.pinHeight, y + self.pinWidth), (x + self.pinHeight, y)], layer=self.pinLayer
                  )
               elif orientation == 180:
                  p.add_polygon(pin, strand,
                     [(x, y), (x, y + self.pinHeight), (x + self.pinWidth, y + self.pinHeight), (x + self.pinWidth, y)], layer=self.pinLayer
                  )
               elif orientation == 270:
                  p.add_polygon(pin, strand,
                     [(x, y), (x, y + self.pinWidth), (x + self.pinHeight, y + self.pinWidth), (x + self.pinHeight, y)], layer=self.pinLayer
                  )
               else:
                  p.add_polygon(pin, strand,
                     [(x, y), (x, y + self.pinHeight), (x + self.pinWidth, y + self.pinHeight), (x + self.pinWidth, y)], layer=self.pinLayer
                  )

               c.add_port(name, center=pin.center, width=self.pinWidth, orientation=orientation, layer=self.pinLayer)
               c << pin
               #cant add size! can add anchor, texttype
               if orientation == 90:
                  c.add_label(text=name, position=pin.center, layer=self.pinLayer, rotation=90, anchor='s')
               elif orientation == 180:
                  c.add_label(text=name, position=pin.center, layer=self.pinLayer, rotation=0, anchor='w')
               elif orientation == 270:
                  c.add_label(text=name, position=pin.center, layer=self.pinLayer, rotation=90, anchor='n')
               else:
                  c.add_label(text=name, position=pin.center, layer=self.pinLayer, rotation=0, anchor='e')

         return c

      c = top(width, height, name=self.name, info=dict(wtf='huh'))
      c.write_gds(f'{self.name}.gds')

   def gen_lef(self):
      now = datetime.now().strftime('%d/%m/%Y %H:%M:%S')

      text = '''VERSION 5.7 ;
  NOWIREEXTENSIONATPIN ON ;
  DIVIDERCHAR "/" ;
  BUSBITCHARS "[]" ;
'''
      # only for cadence?
      #text += f'[BEGINEXT "GDSDUMMY"\n'
      #text += f'  CREATOR "wtf"\n'
      #text += f'  DATE "{now}"\n'
      #text += f'ENDEXT]\n'
      text += f'MACRO {self.name}\n'
      text += f'  CLASS BLOCK ;\n'
      text += f'  FOREIGN {self.name} ;\n'
      text += f'  ORIGIN {self.origin[0]:.3f} {self.origin[1]:.3f} ;\n'
      text += f'  SIZE {self.size[0]:.3f} BY {self.size[1]:.3f} ;\n'

      for p in self.pins:
         for i in range(p.bits):
            if p.bus:
               name = f'{p.name}[{i}]'
            else:
               name = p.name
            text += f'  PIN {name}\n'
            if p.direction == Dir.I:
               text += f'    DIRECTION INPUT ;\n'
               text += f'    USE SIGNAL ;\n'
            elif p.direction == Dir.O:
               text += f'    DIRECTION OUTPUT TRISTATE ;\n'
               text += f'    USE SIGNAL ;\n'
            elif p.direction == Dir.IO:
               text += f'    DIRECTION INOUT ;\n'
               text += f'    USE SIGNAL ;\n'
            elif p.direction == Dir.PWR:
               text += f'    DIRECTION INOUT ;\n'
               text += f'    USE POWER ;\n'
            else:
               raise(Exception(p))

            text += f'    PORT\n'
            text += f'      LAYER met3 ;\n'   # should look up based on layer
            text += f'        RECT {p.polygon[i][0]:.3f} {p.polygon[i][1]:.3f} {p.polygon[i][2]:.3f} {p.polygon[i][3]:.3f} ;\n'
            text += f'    END\n'
            text += f'  END {name}\n'

      # add obs section for boundary rect?
      text += f'END {self.name}\n'
      text += f'END LIBRARY\n\n'
      f = open(f'{self.name}.lef', 'w')
      f.write(text)
      print(f'Created {self.name}.lef')

   def gen_verilog(self):
      now = datetime.now()
      text = '// Generated by gdsDummy       {now.strftime("%d/%m/%Y %H:%M:%S")}\n\n'
      text += f'module {self.name} (\n'
      for p in self.pins:
         if p.direction == Dir.I:
            text += ' input  '
         elif p.direction == Dir.O:
            text += ' output '
         elif p.direction == Dir.IO:
            text += ' inout  '
         elif p.direction == Dir.PWR:
            text += ' inout  '
         else:
            raise Exception(p)
         if p.bus:
            bits = f'[{p.bit_from}:{p.bit_to}] '
         else:
            bits = ''
         text += f'{bits:15s}'
         text += f'{p.name},\n'
      text = text[0:-2]
      text += '\n);\nendmodule\n'
      f = open(f'{self.name}.v', 'w')
      f.write(text)
      print(f'Created {self.name}.v')

   def parse_verilog(self, fn, bitCB=None):
      pins = []
      f = open(fn, 'r')
      text = f.read()
      m = re.search('module\s+(.*?)\s*\((.*)', text, re.MULTILINE | re.DOTALL)
      name = m.group(1)
      module = m.group(2)
      m = re.search('\s*(.*?)\)', module, re.MULTILINE | re.DOTALL)
      ios = m.group(1)
      ios = ios.split(',')
      for io in ios:
         io = io.translate(str.maketrans('', '', ' \n\t\r'))
         m = re.search('\s*(input)*(output)*(inout)*(.*)', io)
         if m.group(1) is None and m.group(2) is None and m.group(3) is None:
            m = re.search(f'\s*(input)\s+(.*){io}', text)
            if m is None:
               m = re.search(f'\s*(output)\s+(.*){io}', text)
            if m is None:
               m = re.search(f'\s*(inout)\s+(.*){io}', text)
         if m.group(1) == 'input':
            direction = Dir.I
         elif m.group(1) == 'output':
            direction = Dir.O
         elif m.group(1) == 'inout':
            if io in GDSDummy.Pwr:
               direction = Dir.PWR
            else:
               direction = Dir.IO
         else:
            direction = Dir.X
         bits = m.group(2)
         bit_from = None
         bit_to = None
         if bits is not None:
            bits = bits.translate(str.maketrans('', '', ' \n\t\r'))
            if bits != '':
               m = re.search('\s*\[(.+?):(.*)\]', bits)
               bit_from = m.group(1)
               if m.group(2) is None:
                  bit_to = bit_from
               else:
                  bit_to = m.group(2)
               # needs to be a callback
               if bitCB is not None:
                  bit_from = bitCB(bit_from)
                  bit_to = bitCB(bit_to)
               else:
                  bit_from = int(bit_from)
                  bit_to = int(bit_to)
               bits = abs(bit_from - bit_to) + 1
            else:
               bits = 1

         # default for now
         if direction == Dir.I:
            edge = (Edge.E)
         else:
            edge = (Edge.W)

         pins.append(Pin(io, direction, edge, bits, bit_from, bit_to))

      return pins

   def gen_constraints(self, compVar):
      text = '# Generated by gdsDummy       {now.strftime("%d/%m/%Y %H:%M:%S")}\n\n'
      text = 'set_input_delay -clock clk [expr $clk_period * .75] ${compVar}/do0'

   def __repr__(self):
      return pprint.pformat(vars(self), indent=4, width=1)


if __name__ == '__main__':

   # *********************** manual version
   pinsPG = [
      Pin('vdd', Dir.PWR, (Edge.S)),
      Pin('gnd', Dir.PWR, (Edge.S))
   ]
   pinsCR = [
      Pin('clk', Dir.I, (Edge.S)),
      Pin('rst', Dir.I, (Edge.S))
   ]
   pinsTest = [
      Pin('delay_lclkr_dc', Dir.I, (Edge.S)),
      Pin('mpw1_dc_b', Dir.I, (Edge.S)),
      Pin('mpw2_dc_b', Dir.I, (Edge.S)),
      Pin('func_sl_force', Dir.I, (Edge.S)),
      Pin('func_sl_thold_0_b', Dir.I, (Edge.S)),
      Pin('func_slp_sl_force', Dir.I, (Edge.S)),
      Pin('func_slp_sl_thold_0_b', Dir.I, (Edge.S)),
      Pin('sg_0', Dir.I, (Edge.S))
   ]
   pinsScan = [
      Pin('scan_in', Dir.I, (Edge.S)),
      Pin('scan_out', Dir.O, (Edge.S))
   ]
   pinsFunc = []
   for i in range(1, 3):
      pinsFunc.append(Pin(f'r_late_en_{i}', Dir.I, (Edge.W)))
      pinsFunc.append(Pin(f'r_addr_in_{i}', Dir.I, (Edge.W), 6, 0, 5))
      pinsFunc.append(Pin(f'r_data_out_{i}', Dir.O, (Edge.E), 78, 0, 77))
   for i in range(1, 5):
      pinsFunc.append(Pin(f'w_late_en_{i}', Dir.I, (Edge.W)))
      pinsFunc.append(Pin(f'w_addr_in_{i}', Dir.I, (Edge.W), 6, 0, 5))
      pinsFunc.append(Pin(f'w_data_in_{i}', Dir.I, (Edge.W), 78, 0, 77))

   ra = GDSDummy('tri_144x78_2r4w', (500, 1500))
   for p in pinsPG:
      ra.add_pin(p)
   for p in pinsCR:
      ra.add_pin(p)
   for p in pinsTest:
      ra.add_pin(p)
   for p in pinsScan:
      ra.add_pin(p)
   for p in pinsFunc:
      ra.add_pin(p)

   ra.gen_verilog()
   ra.gen_gds()
   ra.gen_lef()

   # *********************** automatic from rtl

   def bitCB(bit):
      bit = bit.replace('`GPR_WIDTH', '64')
      bit = bit.replace('`THREADS', '1')
      bit = eval(bit)
      return int(bit)

   ios = ra.parse_verilog('verilog/trilib/tri_64x72_1r1w.v', bitCB)
   ra = GDSDummy('tri_64x72_1r1w', (250, 750))
   for p in ios:
      ra.add_pin(p)

   ra.gen_verilog()
   ra.gen_gds()
   ra.gen_lef()

   # *********************** now cuz i need it

   ios = ra.parse_verilog('verilog/trilib/tri_st_mult.v', bitCB)

   ra = GDSDummy('tri_st_mult', (250, 750))
   for p in ios:
      ra.add_pin(p)

   ra.gen_verilog()
   ra.gen_gds()
   ra.gen_lef()

   # gen_lib() when used for timing (will use fake target timings)
   # gen io constraints if they are used for timing and if you can put on internal nets

